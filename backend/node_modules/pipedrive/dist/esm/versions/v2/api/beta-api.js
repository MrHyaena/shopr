/* tslint:disable */
/* eslint-disable */
/**
 * Pipedrive API v2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from '../base';
/**
 * BetaApi - axios parameter creator
 * @export
 */
export const BetaApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Adds a new activity.
         * @summary Add a new activity
         * @param {AddActivityRequest} [AddActivityRequest]

         * @throws {RequiredError}
         */
        addActivity: (AddActivityRequest) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(AddActivityRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds a new deal.
         * @summary Add a new deal
         * @param {AddDealRequest} [AddDealRequest]

         * @throws {RequiredError}
         */
        addDeal: (AddDealRequest) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/deals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [AddDealProductRequest]

         * @throws {RequiredError}
         */
        addDealProduct: (id, AddDealProductRequest) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addDealProduct', 'id', id);
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full", "deals:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(AddDealProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds a new organization.
         * @summary Add a new organization
         * @param {AddOrganizationRequest} [AddOrganizationRequest]

         * @throws {RequiredError}
         */
        addOrganization: (AddOrganizationRequest) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(AddOrganizationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds a new person.
         * @summary Add a new person
         * @param {AddPersonRequest} [AddPersonRequest]

         * @throws {RequiredError}
         */
        addPerson: (AddPersonRequest) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(AddPersonRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        deleteActivity: (id) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteActivity', 'id', id);
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
         * @summary Delete a discount from a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount

         * @throws {RequiredError}
         */
        deleteAdditionalDiscount: (id, discount_id) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAdditionalDiscount', 'id', id);
            // verify required parameter 'discount_id' is not null or undefined
            assertParamExists('deleteAdditionalDiscount', 'discount_id', discount_id);
            const localVarPath = `/deals/{id}/discounts/{discount_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"discount_id"}}`, encodeURIComponent(String(discount_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        deleteDeal: (id) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDeal', 'id', id);
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID

         * @throws {RequiredError}
         */
        deleteDealProduct: (id, product_attachment_id) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDealProduct', 'id', id);
            // verify required parameter 'product_attachment_id' is not null or undefined
            assertParamExists('deleteDealProduct', 'product_attachment_id', product_attachment_id);
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full", "products:full"], configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete a organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        deleteOrganization: (id) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteOrganization', 'id', id);
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        deletePerson: (id) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePerson', 'id', id);
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns data about all activities.
         * @summary Get all activities
         * @param {number} [filter_id] If supplied, only activities matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only activities owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only activities with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only activities with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getActivities: (filter_id, ids, owner_id, updated_since, updated_until, sort_by, sort_direction, include_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/activities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration);
            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }
            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }
            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }
            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }
            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include

         * @throws {RequiredError}
         */
        getActivity: (id, include_fields) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getActivity', 'id', id);
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:read", "activities:full"], configuration);
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists discounts attached to a deal.
         * @summary List discounts added to a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        getAdditionalDiscounts: (id) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAdditionalDiscounts', 'id', id);
            const localVarPath = `/deals/{id}/discounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the details of a specific deal.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getDeal: (id, include_fields, custom_fields) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDeal', 'id', id);
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration);
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        getDealProducts: (id, cursor, limit, sort_by, sort_direction) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDealProducts', 'id', id);
            const localVarPath = `/deals/{id}/products`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full", "deals:read", "deals:full"], configuration);
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }
            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns data about all deals.
         * @summary Get all deals
         * @param {number} [filter_id] If supplied, only deals matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only deals owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [person_id] If supplied, only deals linked to the specified person are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only deals linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {number} [pipeline_id] If supplied, only deals in the specified pipeline are returned. If filter_id is provided, this is ignored.
         * @param {number} [stage_id] If supplied, only deals in the specified stage are returned. If filter_id is provided, this is ignored.
         * @param {'open' | 'won' | 'lost' | 'deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. Multiple statuses can be included as a comma separated array. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only deals with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only deals with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getDeals: (filter_id, ids, owner_id, person_id, org_id, pipeline_id, stage_id, status, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/deals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration);
            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }
            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }
            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }
            if (pipeline_id !== undefined) {
                localVarQueryParameter['pipeline_id'] = pipeline_id;
            }
            if (stage_id !== undefined) {
                localVarQueryParameter['stage_id'] = stage_id;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }
            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }
            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }
            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns data about products attached to deals
         * @summary Get deal products of several deals
         * @param {Array<number>} deal_ids An array of integers with the IDs of the deals for which the attached products will be returned. A maximum of 100 deal IDs can be provided.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'deal_id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;deal_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        getDealsProducts: (deal_ids, cursor, limit, sort_by, sort_direction) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'deal_ids' is not null or undefined
            assertParamExists('getDealsProducts', 'deal_ids', deal_ids);
            const localVarPath = `/deals/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:read", "products:full", "deals:read", "deals:full"], configuration);
            if (deal_ids) {
                localVarQueryParameter['deal_ids'] = deal_ids;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }
            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the details of a specific organization.
         * @summary Get details of a organization
         * @param {number} id The ID of the organization
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getOrganization: (id, include_fields, custom_fields) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrganization', 'id', id);
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration);
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns data about all organizations.
         * @summary Get all organizations
         * @param {number} [filter_id] If supplied, only organizations matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only organization owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only organizations with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only organizations with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getOrganizations: (filter_id, ids, owner_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/organizations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration);
            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }
            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }
            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }
            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }
            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get details of a person
         * @param {number} id The ID of the person
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getPerson: (id, include_fields, custom_fields) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPerson', 'id', id);
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration);
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get all persons
         * @param {number} [filter_id] If supplied, only persons matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only persons owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only persons linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only persons with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only persons with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getPersons: (filter_id, ids, owner_id, org_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/persons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full"], configuration);
            if (filter_id !== undefined) {
                localVarQueryParameter['filter_id'] = filter_id;
            }
            if (ids !== undefined) {
                localVarQueryParameter['ids'] = ids;
            }
            if (owner_id !== undefined) {
                localVarQueryParameter['owner_id'] = owner_id;
            }
            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }
            if (updated_since !== undefined) {
                localVarQueryParameter['updated_since'] = updated_since;
            }
            if (updated_until !== undefined) {
                localVarQueryParameter['updated_until'] = updated_until;
            }
            if (sort_by !== undefined) {
                localVarQueryParameter['sort_by'] = sort_by;
            }
            if (sort_direction !== undefined) {
                localVarQueryParameter['sort_direction'] = sort_direction;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (custom_fields !== undefined) {
                localVarQueryParameter['custom_fields'] = custom_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
         * @summary Add a discount to a deal
         * @param {number} id The ID of the deal
         * @param {AddAdditionalDiscountRequestBody} [AddAdditionalDiscountRequestBody]

         * @throws {RequiredError}
         */
        postAdditionalDiscount: (id, AddAdditionalDiscountRequestBody) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postAdditionalDiscount', 'id', id);
            const localVarPath = `/deals/{id}/discounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'POST' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(AddAdditionalDiscountRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {'open' | 'won' | 'lost'} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {'deal.cc_email'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchDeals: (term, fields, exact_match, person_id, organization_id, status, include_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchDeals', 'term', term);
            const localVarPath = `/deals/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full", "search:read"], configuration);
            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }
            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }
            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'deal.cc_email' | 'person.picture' | 'product.price'} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchItem: (term, item_types, fields, search_for_related_items, exact_match, include_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchItem', 'term', term);
            const localVarPath = `/itemSearch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["search:read"], configuration);
            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }
            if (item_types !== undefined) {
                localVarQueryParameter['item_types'] = item_types;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (search_for_related_items !== undefined) {
                localVarQueryParameter['search_for_related_items'] = search_for_related_items;
            }
            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if &#x60;match&#x60; is &#x60;exact&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project'} entity_type The type of the field to perform the search from
         * @param {string} field The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {'exact' | 'beginning' | 'middle'} [match] The type of match used against the term. The search &lt;b&gt;is&lt;/b&gt; case sensitive.&lt;br/&gt;&lt;br/&gt; E.g. in case of searching for a value &#x60;monkey&#x60;, &lt;ul&gt; &lt;li&gt;with &#x60;exact&#x60; match, you will only find it if term is &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;beginning&#x60; match, you will only find it if the term matches the beginning or the whole string, e.g. &#x60;monk&#x60; and &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;middle&#x60; match, you will find the it if the term matches any substring of the value, e.g. &#x60;onk&#x60; and &#x60;ke&#x60;&lt;/li&gt; &lt;/ul&gt;.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchItemByField: (term, entity_type, field, match, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchItemByField', 'term', term);
            // verify required parameter 'entity_type' is not null or undefined
            assertParamExists('searchItemByField', 'entity_type', entity_type);
            // verify required parameter 'field' is not null or undefined
            assertParamExists('searchItemByField', 'field', field);
            const localVarPath = `/itemSearch/field`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["search:read"], configuration);
            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }
            if (entity_type !== undefined) {
                localVarQueryParameter['entity_type'] = entity_type;
            }
            if (match !== undefined) {
                localVarQueryParameter['match'] = match;
            }
            if (field !== undefined) {
                localVarQueryParameter['field'] = field;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {'lead.was_seen'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchLeads: (term, fields, exact_match, person_id, organization_id, include_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchLeads', 'term', term);
            const localVarPath = `/leads/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["leads:read", "leads:full", "search:read"], configuration);
            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }
            if (person_id !== undefined) {
                localVarQueryParameter['person_id'] = person_id;
            }
            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'address' | 'custom_fields' | 'notes' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchOrganization: (term, fields, exact_match, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchOrganization', 'term', term);
            const localVarPath = `/organizations/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "search:read"], configuration);
            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchPersons: (term, fields, exact_match, organization_id, include_fields, limit, cursor) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchPersons', 'term', term);
            const localVarPath = `/persons/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'GET' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:read", "contacts:full", "search:read"], configuration);
            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (exact_match !== undefined) {
                localVarQueryParameter['exact_match'] = exact_match;
            }
            if (organization_id !== undefined) {
                localVarQueryParameter['organization_id'] = organization_id;
            }
            if (include_fields !== undefined) {
                localVarQueryParameter['include_fields'] = include_fields;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the properties of an activity.
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {AddActivityRequest} [AddActivityRequest]

         * @throws {RequiredError}
         */
        updateActivity: (id, AddActivityRequest) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateActivity', 'id', id);
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["activities:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(AddActivityRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
         * @summary Update a discount added to a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount
         * @param {UpdateAdditionalDiscountRequestBody} [UpdateAdditionalDiscountRequestBody]

         * @throws {RequiredError}
         */
        updateAdditionalDiscount: (id, discount_id, UpdateAdditionalDiscountRequestBody) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAdditionalDiscount', 'id', id);
            // verify required parameter 'discount_id' is not null or undefined
            assertParamExists('updateAdditionalDiscount', 'discount_id', discount_id);
            const localVarPath = `/deals/{id}/discounts/{discount_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"discount_id"}}`, encodeURIComponent(String(discount_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:read", "deals:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateAdditionalDiscountRequestBody, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the properties of a deal.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [UpdateDealRequest]

         * @throws {RequiredError}
         */
        updateDeal: (id, UpdateDealRequest) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDeal', 'id', id);
            const localVarPath = `/deals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["deals:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateDealRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {UpdateDealProductRequest} [UpdateDealProductRequest]

         * @throws {RequiredError}
         */
        updateDealProduct: (id, product_attachment_id, UpdateDealProductRequest) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateDealProduct', 'id', id);
            // verify required parameter 'product_attachment_id' is not null or undefined
            assertParamExists('updateDealProduct', 'product_attachment_id', product_attachment_id);
            const localVarPath = `/deals/{id}/products/{product_attachment_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"product_attachment_id"}}`, encodeURIComponent(String(product_attachment_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["products:full", "deals:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateDealProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the properties of a organization.
         * @summary Update a organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [UpdateOrganizationRequest]

         * @throws {RequiredError}
         */
        updateOrganization: (id, UpdateOrganizationRequest) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOrganization', 'id', id);
            const localVarPath = `/organizations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(UpdateOrganizationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates the properties of a person.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest]

         * @throws {RequiredError}
         */
        updatePerson: (id, UpdatePersonRequest) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePerson', 'id', id);
            const localVarPath = `/persons/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, baseOptions);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication api_key required
            yield setApiKeyToObject(localVarQueryParameter, "api_token", configuration);
            // authentication oauth2 required
            // oauth required
            yield setOAuthToObject(localVarHeaderParameter, "oauth2", ["contacts:full"], configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions);
            localVarRequestOptions.data = serializeDataIfNeeded(UpdatePersonRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BetaApi - functional programming interface
 * @export
 */
export const BetaApiFp = function (configuration) {
    const localVarAxiosParamCreator = BetaApiAxiosParamCreator(configuration);
    return {
        /**
         * Adds a new activity.
         * @summary Add a new activity
         * @param {AddActivityRequest} [AddActivityRequest]

         * @throws {RequiredError}
         */
        addActivity(AddActivityRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addActivity(AddActivityRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Adds a new deal.
         * @summary Add a new deal
         * @param {AddDealRequest} [AddDealRequest]

         * @throws {RequiredError}
         */
        addDeal(AddDealRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addDeal(AddDealRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {number} id The ID of the deal
         * @param {AddDealProductRequest} [AddDealProductRequest]

         * @throws {RequiredError}
         */
        addDealProduct(id, AddDealProductRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addDealProduct(id, AddDealProductRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Adds a new organization.
         * @summary Add a new organization
         * @param {AddOrganizationRequest} [AddOrganizationRequest]

         * @throws {RequiredError}
         */
        addOrganization(AddOrganizationRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addOrganization(AddOrganizationRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Adds a new person.
         * @summary Add a new person
         * @param {AddPersonRequest} [AddPersonRequest]

         * @throws {RequiredError}
         */
        addPerson(AddPersonRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addPerson(AddPersonRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {number} id The ID of the activity

         * @throws {RequiredError}
         */
        deleteActivity(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteActivity(id);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
         * @summary Delete a discount from a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount

         * @throws {RequiredError}
         */
        deleteAdditionalDiscount(id, discount_id) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAdditionalDiscount(id, discount_id);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        deleteDeal(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDeal(id);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The product attachment ID

         * @throws {RequiredError}
         */
        deleteDealProduct(id, product_attachment_id) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteDealProduct(id, product_attachment_id);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete a organization
         * @param {number} id The ID of the organization

         * @throws {RequiredError}
         */
        deleteOrganization(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteOrganization(id);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {number} id The ID of the person

         * @throws {RequiredError}
         */
        deletePerson(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePerson(id);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns data about all activities.
         * @summary Get all activities
         * @param {number} [filter_id] If supplied, only activities matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only activities owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only activities with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only activities with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getActivities(filter_id, ids, owner_id, updated_since, updated_until, sort_by, sort_direction, include_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActivities(filter_id, ids, owner_id, updated_since, updated_until, sort_by, sort_direction, include_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {number} id The ID of the activity
         * @param {'attendees'} [include_fields] Optional comma separated string array of additional fields to include

         * @throws {RequiredError}
         */
        getActivity(id, include_fields) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getActivity(id, include_fields);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Lists discounts attached to a deal.
         * @summary List discounts added to a deal
         * @param {number} id The ID of the deal

         * @throws {RequiredError}
         */
        getAdditionalDiscounts(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAdditionalDiscounts(id);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns the details of a specific deal.
         * @summary Get details of a deal
         * @param {number} id The ID of the deal
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getDeal(id, include_fields, custom_fields) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDeal(id, include_fields, custom_fields);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {number} id The ID of the deal
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        getDealProducts(id, cursor, limit, sort_by, sort_direction) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDealProducts(id, cursor, limit, sort_by, sort_direction);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns data about all deals.
         * @summary Get all deals
         * @param {number} [filter_id] If supplied, only deals matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only deals owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [person_id] If supplied, only deals linked to the specified person are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only deals linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {number} [pipeline_id] If supplied, only deals in the specified pipeline are returned. If filter_id is provided, this is ignored.
         * @param {number} [stage_id] If supplied, only deals in the specified stage are returned. If filter_id is provided, this is ignored.
         * @param {'open' | 'won' | 'lost' | 'deleted'} [status] Only fetch deals with a specific status. If omitted, all not deleted deals are returned. If set to deleted, deals that have been deleted up to 30 days ago will be included. Multiple statuses can be included as a comma separated array. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only deals with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only deals with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'first_won_time' | 'products_count' | 'files_count' | 'notes_count' | 'followers_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'participants_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getDeals(filter_id, ids, owner_id, person_id, org_id, pipeline_id, stage_id, status, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDeals(filter_id, ids, owner_id, person_id, org_id, pipeline_id, stage_id, status, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns data about products attached to deals
         * @summary Get deal products of several deals
         * @param {Array<number>} deal_ids An array of integers with the IDs of the deals for which the attached products will be returned. A maximum of 100 deal IDs can be provided.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {'id' | 'deal_id' | 'add_time' | 'update_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;deal_id&#x60;, &#x60;add_time&#x60;, &#x60;update_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.

         * @throws {RequiredError}
         */
        getDealsProducts(deal_ids, cursor, limit, sort_by, sort_direction) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getDealsProducts(deal_ids, cursor, limit, sort_by, sort_direction);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns the details of a specific organization.
         * @summary Get details of a organization
         * @param {number} id The ID of the organization
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getOrganization(id, include_fields, custom_fields) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganization(id, include_fields, custom_fields);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns data about all organizations.
         * @summary Get all organizations
         * @param {number} [filter_id] If supplied, only organizations matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only organization owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only organizations with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only organizations with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'email_messages_count' | 'people_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count'} [include_fields] Optional comma separated string array of additional fields to include
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getOrganizations(filter_id, ids, owner_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOrganizations(filter_id, ids, owner_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get details of a person
         * @param {number} id The ID of the person
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.

         * @throws {RequiredError}
         */
        getPerson(id, include_fields, custom_fields) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPerson(id, include_fields, custom_fields);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get all persons
         * @param {number} [filter_id] If supplied, only persons matching the specified filter are returned
         * @param {string} [ids] Optional comma separated string array of up to 100 entity ids to fetch. If filter_id is provided, this is ignored. If any of the requested entities do not exist or are not visible, they are not included in the response.
         * @param {number} [owner_id] If supplied, only persons owned by the specified user are returned. If filter_id is provided, this is ignored.
         * @param {number} [org_id] If supplied, only persons linked to the specified organization are returned. If filter_id is provided, this is ignored.
         * @param {string} [updated_since] If set, only persons with an &#x60;update_time&#x60; later than or equal to this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {string} [updated_until] If set, only persons with an &#x60;update_time&#x60; earlier than this time are returned. In RFC3339 format, e.g. 2025-01-01T10:20:00Z.
         * @param {'id' | 'update_time' | 'add_time'} [sort_by] The field to sort by. Supported fields: &#x60;id&#x60;, &#x60;update_time&#x60;, &#x60;add_time&#x60;.
         * @param {'asc' | 'desc'} [sort_direction] The sorting direction. Supported values: &#x60;asc&#x60;, &#x60;desc&#x60;.
         * @param {'next_activity_id' | 'last_activity_id' | 'open_deals_count' | 'related_open_deals_count' | 'closed_deals_count' | 'related_closed_deals_count' | 'participant_open_deals_count' | 'participant_closed_deals_count' | 'email_messages_count' | 'activities_count' | 'done_activities_count' | 'undone_activities_count' | 'files_count' | 'notes_count' | 'followers_count' | 'won_deals_count' | 'related_won_deals_count' | 'lost_deals_count' | 'related_lost_deals_count' | 'last_incoming_mail_time' | 'last_outgoing_mail_time' | 'marketing_status' | 'doi_status'} [include_fields] Optional comma separated string array of additional fields to include. &#x60;marketing_status&#x60; and &#x60;doi_status&#x60; can only be included if the company has marketing app enabled.
         * @param {string} [custom_fields] Optional comma separated string array of custom fields keys to include. If you are only interested in a particular set of custom fields, please use this parameter for faster results and smaller response.&lt;br/&gt;A maximum of 15 keys is allowed.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        getPersons(filter_id, ids, owner_id, org_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPersons(filter_id, ids, owner_id, org_id, updated_since, updated_until, sort_by, sort_direction, include_fields, custom_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
         * @summary Add a discount to a deal
         * @param {number} id The ID of the deal
         * @param {AddAdditionalDiscountRequestBody} [AddAdditionalDiscountRequestBody]

         * @throws {RequiredError}
         */
        postAdditionalDiscount(id, AddAdditionalDiscountRequestBody) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.postAdditionalDiscount(id, AddAdditionalDiscountRequestBody);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter deals by the provided person ID. The upper limit of found deals associated with the person is 2000.
         * @param {number} [organization_id] Will filter deals by the provided organization ID. The upper limit of found deals associated with the organization is 2000.
         * @param {'open' | 'won' | 'lost'} [status] Will filter deals by the provided specific status. open &#x3D; Open, won &#x3D; Won, lost &#x3D; Lost. The upper limit of found deals associated with the status is 2000.
         * @param {'deal.cc_email'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchDeals(term, fields, exact_match, person_id, organization_id, status, include_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchDeals(term, fields, exact_match, person_id, organization_id, status, include_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'person' | 'organization' | 'product' | 'lead' | 'file' | 'mail_attachment' | 'project'} [item_types] A comma-separated string array. The type of items to perform the search from. Defaults to all.
         * @param {'address' | 'code' | 'custom_fields' | 'email' | 'name' | 'notes' | 'organization_name' | 'person_name' | 'phone' | 'title' | 'description'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all. Relevant for each item type are:&lt;br&gt; &lt;table&gt; &lt;tr&gt;&lt;th&gt;&lt;b&gt;Item type&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Field&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Deal&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Person&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;email&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;, &#x60;phone&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Organization&lt;/td&gt;&lt;td&gt;&#x60;address&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;, &#x60;notes&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Product&lt;/td&gt;&lt;td&gt;&#x60;code&#x60;, &#x60;custom_fields&#x60;, &#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Lead&lt;/td&gt;&lt;td&gt;&#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;email&#x60;, &#x60;organization_name&#x60;, &#x60;person_name&#x60;, &#x60;phone&#x60;, &#x60;title&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;File&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Mail attachment&lt;/td&gt;&lt;td&gt;&#x60;name&#x60;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Project&lt;/td&gt;&lt;td&gt; &#x60;custom_fields&#x60;, &#x60;notes&#x60;, &#x60;title&#x60;, &#x60;description&#x60; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;br&gt; Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.&lt;br/&gt; When searching for leads, the email, organization_name, person_name, and phone fields will return results only for leads not linked to contacts. For searching leads by person or organization values, please use &#x60;search_for_related_items&#x60;.
         * @param {boolean} [search_for_related_items] When enabled, the response will include up to 100 newest related leads and 100 newest related deals for each found person and organization and up to 100 newest related persons for each found organization
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {'deal.cc_email' | 'person.picture' | 'product.price'} [include_fields] A comma-separated string array. Supports including optional fields in the results which are not provided by default.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchItem(term, item_types, fields, search_for_related_items, exact_match, include_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchItem(term, item_types, fields, search_for_related_items, exact_match, include_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if &#x60;match&#x60; is &#x60;exact&#x60;). Please note that the search term has to be URL encoded.
         * @param {'deal' | 'lead' | 'person' | 'organization' | 'product' | 'project'} entity_type The type of the field to perform the search from
         * @param {string} field The key of the field to search from. The field key can be obtained by fetching the list of the fields using any of the fields\&#39; API GET methods (dealFields, personFields, etc.). Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {'exact' | 'beginning' | 'middle'} [match] The type of match used against the term. The search &lt;b&gt;is&lt;/b&gt; case sensitive.&lt;br/&gt;&lt;br/&gt; E.g. in case of searching for a value &#x60;monkey&#x60;, &lt;ul&gt; &lt;li&gt;with &#x60;exact&#x60; match, you will only find it if term is &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;beginning&#x60; match, you will only find it if the term matches the beginning or the whole string, e.g. &#x60;monk&#x60; and &#x60;monkey&#x60;&lt;/li&gt; &lt;li&gt;with &#x60;middle&#x60; match, you will find the it if the term matches any substring of the value, e.g. &#x60;onk&#x60; and &#x60;ke&#x60;&lt;/li&gt; &lt;/ul&gt;.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchItemByField(term, entity_type, field, match, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchItemByField(term, entity_type, field, match, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'notes' | 'title'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [person_id] Will filter leads by the provided person ID. The upper limit of found leads associated with the person is 2000.
         * @param {number} [organization_id] Will filter leads by the provided organization ID. The upper limit of found leads associated with the organization is 2000.
         * @param {'lead.was_seen'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchLeads(term, fields, exact_match, person_id, organization_id, include_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchLeads(term, fields, exact_match, person_id, organization_id, include_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'address' | 'custom_fields' | 'notes' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchOrganization(term, fields, exact_match, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchOrganization(term, fields, exact_match, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {string} term The search term to look for. Minimum 2 characters (or 1 if using &#x60;exact_match&#x60;). Please note that the search term has to be URL encoded.
         * @param {'custom_fields' | 'email' | 'notes' | 'phone' | 'name'} [fields] A comma-separated string array. The fields to perform the search from. Defaults to all of them. Only the following custom field types are searchable: &#x60;address&#x60;, &#x60;varchar&#x60;, &#x60;text&#x60;, &#x60;varchar_auto&#x60;, &#x60;double&#x60;, &#x60;monetary&#x60; and &#x60;phone&#x60;. Read more about searching by custom fields &lt;a href&#x3D;\&quot;https://support.pipedrive.com/en/article/search-finding-what-you-need#searching-by-custom-fields\&quot; target&#x3D;\&quot;_blank\&quot; rel&#x3D;\&quot;noopener noreferrer\&quot;&gt;here&lt;/a&gt;.
         * @param {boolean} [exact_match] When enabled, only full exact matches against the given term are returned. It is &lt;b&gt;not&lt;/b&gt; case sensitive.
         * @param {number} [organization_id] Will filter persons by the provided organization ID. The upper limit of found persons associated with the organization is 2000.
         * @param {'person.picture'} [include_fields] Supports including optional fields in the results which are not provided by default
         * @param {number} [limit] For pagination, the limit of entries to be returned. If not provided, 100 items will be returned. Please note that a maximum value of 500 is allowed.
         * @param {string} [cursor] For pagination, the marker (an opaque string value) representing the first item on the next page

         * @throws {RequiredError}
         */
        searchPersons(term, fields, exact_match, organization_id, include_fields, limit, cursor) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchPersons(term, fields, exact_match, organization_id, include_fields, limit, cursor);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Updates the properties of an activity.
         * @summary Update an activity
         * @param {number} id The ID of the activity
         * @param {AddActivityRequest} [AddActivityRequest]

         * @throws {RequiredError}
         */
        updateActivity(id, AddActivityRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateActivity(id, AddActivityRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
         * @summary Update a discount added to a deal
         * @param {number} id The ID of the deal
         * @param {number} discount_id The ID of the discount
         * @param {UpdateAdditionalDiscountRequestBody} [UpdateAdditionalDiscountRequestBody]

         * @throws {RequiredError}
         */
        updateAdditionalDiscount(id, discount_id, UpdateAdditionalDiscountRequestBody) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAdditionalDiscount(id, discount_id, UpdateAdditionalDiscountRequestBody);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Updates the properties of a deal.
         * @summary Update a deal
         * @param {number} id The ID of the deal
         * @param {UpdateDealRequest} [UpdateDealRequest]

         * @throws {RequiredError}
         */
        updateDeal(id, UpdateDealRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDeal(id, UpdateDealRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {number} id The ID of the deal
         * @param {number} product_attachment_id The ID of the deal-product (the ID of the product attached to the deal)
         * @param {UpdateDealProductRequest} [UpdateDealProductRequest]

         * @throws {RequiredError}
         */
        updateDealProduct(id, product_attachment_id, UpdateDealProductRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateDealProduct(id, product_attachment_id, UpdateDealProductRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Updates the properties of a organization.
         * @summary Update a organization
         * @param {number} id The ID of the organization
         * @param {UpdateOrganizationRequest} [UpdateOrganizationRequest]

         * @throws {RequiredError}
         */
        updateOrganization(id, UpdateOrganizationRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateOrganization(id, UpdateOrganizationRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
        /**
         * Updates the properties of a person.
         * @summary Update a person
         * @param {number} id The ID of the person
         * @param {UpdatePersonRequest} [UpdatePersonRequest]

         * @throws {RequiredError}
         */
        updatePerson(id, UpdatePersonRequest) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePerson(id, UpdatePersonRequest);
                return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
            });
        },
    };
};
/**
 * BetaApi - factory interface
 * @export
 */
export const BetaApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BetaApiFp(configuration);
    return {
        /**
         * Adds a new activity.
         * @summary Add a new activity
         * @param {BetaApiAddActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addActivity(requestParameters = {}) {
            return localVarFp.addActivity(requestParameters.AddActivityRequest).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new deal.
         * @summary Add a new deal
         * @param {BetaApiAddDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDeal(requestParameters = {}) {
            return localVarFp.addDeal(requestParameters.AddDealRequest).then((request) => request(axios, basePath));
        },
        /**
         * Adds a product to a deal, creating a new item called a deal-product.
         * @summary Add a product to a deal
         * @param {BetaApiAddDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addDealProduct(requestParameters) {
            return localVarFp.addDealProduct(requestParameters.id, requestParameters.AddDealProductRequest).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new organization.
         * @summary Add a new organization
         * @param {BetaApiAddOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addOrganization(requestParameters = {}) {
            return localVarFp.addOrganization(requestParameters.AddOrganizationRequest).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new person.
         * @summary Add a new person
         * @param {BetaApiAddPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        addPerson(requestParameters = {}) {
            return localVarFp.addPerson(requestParameters.AddPersonRequest).then((request) => request(axios, basePath));
        },
        /**
         * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
         * @summary Delete an activity
         * @param {BetaApiDeleteActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteActivity(requestParameters) {
            return localVarFp.deleteActivity(requestParameters.id).then((request) => request(axios, basePath));
        },
        /**
         * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
         * @summary Delete a discount from a deal
         * @param {BetaApiDeleteAdditionalDiscountRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteAdditionalDiscount(requestParameters) {
            return localVarFp.deleteAdditionalDiscount(requestParameters.id, requestParameters.discount_id).then((request) => request(axios, basePath));
        },
        /**
         * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
         * @summary Delete a deal
         * @param {BetaApiDeleteDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDeal(requestParameters) {
            return localVarFp.deleteDeal(requestParameters.id).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a product attachment from a deal, using the `product_attachment_id`.
         * @summary Delete an attached product from a deal
         * @param {BetaApiDeleteDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteDealProduct(requestParameters) {
            return localVarFp.deleteDealProduct(requestParameters.id, requestParameters.product_attachment_id).then((request) => request(axios, basePath));
        },
        /**
         * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
         * @summary Delete a organization
         * @param {BetaApiDeleteOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deleteOrganization(requestParameters) {
            return localVarFp.deleteOrganization(requestParameters.id).then((request) => request(axios, basePath));
        },
        /**
         * Marks a person as deleted. After 30 days, the person will be permanently deleted.
         * @summary Delete a person
         * @param {BetaApiDeletePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        deletePerson(requestParameters) {
            return localVarFp.deletePerson(requestParameters.id).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all activities.
         * @summary Get all activities
         * @param {BetaApiGetActivitiesRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getActivities(requestParameters = {}) {
            return localVarFp.getActivities(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific activity.
         * @summary Get details of an activity
         * @param {BetaApiGetActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getActivity(requestParameters) {
            return localVarFp.getActivity(requestParameters.id, requestParameters.include_fields).then((request) => request(axios, basePath));
        },
        /**
         * Lists discounts attached to a deal.
         * @summary List discounts added to a deal
         * @param {BetaApiGetAdditionalDiscountsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getAdditionalDiscounts(requestParameters) {
            return localVarFp.getAdditionalDiscounts(requestParameters.id).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific deal.
         * @summary Get details of a deal
         * @param {BetaApiGetDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDeal(requestParameters) {
            return localVarFp.getDeal(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields).then((request) => request(axios, basePath));
        },
        /**
         * Lists products attached to a deal.
         * @summary List products attached to a deal
         * @param {BetaApiGetDealProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealProducts(requestParameters) {
            return localVarFp.getDealProducts(requestParameters.id, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all deals.
         * @summary Get all deals
         * @param {BetaApiGetDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDeals(requestParameters = {}) {
            return localVarFp.getDeals(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.person_id, requestParameters.org_id, requestParameters.pipeline_id, requestParameters.stage_id, requestParameters.status, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about products attached to deals
         * @summary Get deal products of several deals
         * @param {BetaApiGetDealsProductsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getDealsProducts(requestParameters) {
            return localVarFp.getDealsProducts(requestParameters.deal_ids, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific organization.
         * @summary Get details of a organization
         * @param {BetaApiGetOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganization(requestParameters) {
            return localVarFp.getOrganization(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all organizations.
         * @summary Get all organizations
         * @param {BetaApiGetOrganizationsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getOrganizations(requestParameters = {}) {
            return localVarFp.getOrganizations(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get details of a person
         * @param {BetaApiGetPersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPerson(requestParameters) {
            return localVarFp.getPerson(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields).then((request) => request(axios, basePath));
        },
        /**
         * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
         * @summary Get all persons
         * @param {BetaApiGetPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        getPersons(requestParameters = {}) {
            return localVarFp.getPersons(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.org_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
         * @summary Add a discount to a deal
         * @param {BetaApiPostAdditionalDiscountRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        postAdditionalDiscount(requestParameters) {
            return localVarFp.postAdditionalDiscount(requestParameters.id, requestParameters.AddAdditionalDiscountRequestBody).then((request) => request(axios, basePath));
        },
        /**
         * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
         * @summary Search deals
         * @param {BetaApiSearchDealsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchDeals(requestParameters) {
            return localVarFp.searchDeals(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.status, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search from your choice of item types and fields.
         * @summary Perform a search from multiple item types
         * @param {BetaApiSearchItemRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchItem(requestParameters) {
            return localVarFp.searchItem(requestParameters.term, requestParameters.item_types, requestParameters.fields, requestParameters.search_for_related_items, requestParameters.exact_match, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
         * @summary Perform a search using a specific field from an item type
         * @param {BetaApiSearchItemByFieldRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchItemByField(requestParameters) {
            return localVarFp.searchItemByField(requestParameters.term, requestParameters.entity_type, requestParameters.field, requestParameters.match, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
         * @summary Search leads
         * @param {BetaApiSearchLeadsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchLeads(requestParameters) {
            return localVarFp.searchLeads(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
         * @summary Search organizations
         * @param {BetaApiSearchOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchOrganization(requestParameters) {
            return localVarFp.searchOrganization(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
         * @summary Search persons
         * @param {BetaApiSearchPersonsRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        searchPersons(requestParameters) {
            return localVarFp.searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of an activity.
         * @summary Update an activity
         * @param {BetaApiUpdateActivityRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateActivity(requestParameters) {
            return localVarFp.updateActivity(requestParameters.id, requestParameters.AddActivityRequest).then((request) => request(axios, basePath));
        },
        /**
         * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
         * @summary Update a discount added to a deal
         * @param {BetaApiUpdateAdditionalDiscountRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateAdditionalDiscount(requestParameters) {
            return localVarFp.updateAdditionalDiscount(requestParameters.id, requestParameters.discount_id, requestParameters.UpdateAdditionalDiscountRequestBody).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a deal.
         * @summary Update a deal
         * @param {BetaApiUpdateDealRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateDeal(requestParameters) {
            return localVarFp.updateDeal(requestParameters.id, requestParameters.UpdateDealRequest).then((request) => request(axios, basePath));
        },
        /**
         * Updates the details of the product that has been attached to a deal.
         * @summary Update the product attached to a deal
         * @param {BetaApiUpdateDealProductRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateDealProduct(requestParameters) {
            return localVarFp.updateDealProduct(requestParameters.id, requestParameters.product_attachment_id, requestParameters.UpdateDealProductRequest).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a organization.
         * @summary Update a organization
         * @param {BetaApiUpdateOrganizationRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updateOrganization(requestParameters) {
            return localVarFp.updateOrganization(requestParameters.id, requestParameters.UpdateOrganizationRequest).then((request) => request(axios, basePath));
        },
        /**
         * Updates the properties of a person.
         * @summary Update a person
         * @param {BetaApiUpdatePersonRequest} requestParameters Request parameters.

         * @throws {RequiredError}
         */
        updatePerson(requestParameters) {
            return localVarFp.updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BetaApi - object-oriented interface
 * @export
 * @class BetaApi
 * @extends {BaseAPI}
 */
export class BetaApi extends BaseAPI {
    /**
     * Adds a new activity.
     * @summary Add a new activity
     * @param {BetaApiAddActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    addActivity(requestParameters = {}) {
        return BetaApiFp(this.configuration).addActivity(requestParameters.AddActivityRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a new deal.
     * @summary Add a new deal
     * @param {BetaApiAddDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    addDeal(requestParameters = {}) {
        return BetaApiFp(this.configuration).addDeal(requestParameters.AddDealRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a product to a deal, creating a new item called a deal-product.
     * @summary Add a product to a deal
     * @param {BetaApiAddDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    addDealProduct(requestParameters) {
        return BetaApiFp(this.configuration).addDealProduct(requestParameters.id, requestParameters.AddDealProductRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a new organization.
     * @summary Add a new organization
     * @param {BetaApiAddOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    addOrganization(requestParameters = {}) {
        return BetaApiFp(this.configuration).addOrganization(requestParameters.AddOrganizationRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a new person.
     * @summary Add a new person
     * @param {BetaApiAddPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    addPerson(requestParameters = {}) {
        return BetaApiFp(this.configuration).addPerson(requestParameters.AddPersonRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Marks an activity as deleted. After 30 days, the activity will be permanently deleted.
     * @summary Delete an activity
     * @param {BetaApiDeleteActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    deleteActivity(requestParameters) {
        return BetaApiFp(this.configuration).deleteActivity(requestParameters.id).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes a discount from a deal, changing the deal value if the deal has one-time products attached.
     * @summary Delete a discount from a deal
     * @param {BetaApiDeleteAdditionalDiscountRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    deleteAdditionalDiscount(requestParameters) {
        return BetaApiFp(this.configuration).deleteAdditionalDiscount(requestParameters.id, requestParameters.discount_id).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Marks a deal as deleted. After 30 days, the deal will be permanently deleted.
     * @summary Delete a deal
     * @param {BetaApiDeleteDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    deleteDeal(requestParameters) {
        return BetaApiFp(this.configuration).deleteDeal(requestParameters.id).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a product attachment from a deal, using the `product_attachment_id`.
     * @summary Delete an attached product from a deal
     * @param {BetaApiDeleteDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    deleteDealProduct(requestParameters) {
        return BetaApiFp(this.configuration).deleteDealProduct(requestParameters.id, requestParameters.product_attachment_id).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Marks a organization as deleted. After 30 days, the organization will be permanently deleted.
     * @summary Delete a organization
     * @param {BetaApiDeleteOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    deleteOrganization(requestParameters) {
        return BetaApiFp(this.configuration).deleteOrganization(requestParameters.id).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Marks a person as deleted. After 30 days, the person will be permanently deleted.
     * @summary Delete a person
     * @param {BetaApiDeletePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    deletePerson(requestParameters) {
        return BetaApiFp(this.configuration).deletePerson(requestParameters.id).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns data about all activities.
     * @summary Get all activities
     * @param {BetaApiGetActivitiesRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getActivities(requestParameters = {}) {
        return BetaApiFp(this.configuration).getActivities(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the details of a specific activity.
     * @summary Get details of an activity
     * @param {BetaApiGetActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getActivity(requestParameters) {
        return BetaApiFp(this.configuration).getActivity(requestParameters.id, requestParameters.include_fields).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists discounts attached to a deal.
     * @summary List discounts added to a deal
     * @param {BetaApiGetAdditionalDiscountsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getAdditionalDiscounts(requestParameters) {
        return BetaApiFp(this.configuration).getAdditionalDiscounts(requestParameters.id).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the details of a specific deal.
     * @summary Get details of a deal
     * @param {BetaApiGetDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getDeal(requestParameters) {
        return BetaApiFp(this.configuration).getDeal(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists products attached to a deal.
     * @summary List products attached to a deal
     * @param {BetaApiGetDealProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getDealProducts(requestParameters) {
        return BetaApiFp(this.configuration).getDealProducts(requestParameters.id, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns data about all deals.
     * @summary Get all deals
     * @param {BetaApiGetDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getDeals(requestParameters = {}) {
        return BetaApiFp(this.configuration).getDeals(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.person_id, requestParameters.org_id, requestParameters.pipeline_id, requestParameters.stage_id, requestParameters.status, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns data about products attached to deals
     * @summary Get deal products of several deals
     * @param {BetaApiGetDealsProductsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getDealsProducts(requestParameters) {
        return BetaApiFp(this.configuration).getDealsProducts(requestParameters.deal_ids, requestParameters.cursor, requestParameters.limit, requestParameters.sort_by, requestParameters.sort_direction).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the details of a specific organization.
     * @summary Get details of a organization
     * @param {BetaApiGetOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getOrganization(requestParameters) {
        return BetaApiFp(this.configuration).getOrganization(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns data about all organizations.
     * @summary Get all organizations
     * @param {BetaApiGetOrganizationsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getOrganizations(requestParameters = {}) {
        return BetaApiFp(this.configuration).getOrganizations(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the details of a specific person. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
     * @summary Get details of a person
     * @param {BetaApiGetPersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getPerson(requestParameters) {
        return BetaApiFp(this.configuration).getPerson(requestParameters.id, requestParameters.include_fields, requestParameters.custom_fields).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns data about all persons. Fields `ims`, `postal_address`, `notes`, `birthday`, and `job_title` are only included if contact sync is enabled for the company.
     * @summary Get all persons
     * @param {BetaApiGetPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    getPersons(requestParameters = {}) {
        return BetaApiFp(this.configuration).getPersons(requestParameters.filter_id, requestParameters.ids, requestParameters.owner_id, requestParameters.org_id, requestParameters.updated_since, requestParameters.updated_until, requestParameters.sort_by, requestParameters.sort_direction, requestParameters.include_fields, requestParameters.custom_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a discount to a deal changing, the deal value if the deal has one-time products attached.
     * @summary Add a discount to a deal
     * @param {BetaApiPostAdditionalDiscountRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    postAdditionalDiscount(requestParameters) {
        return BetaApiFp(this.configuration).postAdditionalDiscount(requestParameters.id, requestParameters.AddAdditionalDiscountRequestBody).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches all deals by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found deals can be filtered by the person ID and the organization ID.
     * @summary Search deals
     * @param {BetaApiSearchDealsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    searchDeals(requestParameters) {
        return BetaApiFp(this.configuration).searchDeals(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.status, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Performs a search from your choice of item types and fields.
     * @summary Perform a search from multiple item types
     * @param {BetaApiSearchItemRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    searchItem(requestParameters) {
        return BetaApiFp(this.configuration).searchItem(requestParameters.term, requestParameters.item_types, requestParameters.fields, requestParameters.search_for_related_items, requestParameters.exact_match, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Performs a search from the values of a specific field. Results can either be the distinct values of the field (useful for searching autocomplete field values), or the IDs of actual items (deals, leads, persons, organizations or products).
     * @summary Perform a search using a specific field from an item type
     * @param {BetaApiSearchItemByFieldRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    searchItemByField(requestParameters) {
        return BetaApiFp(this.configuration).searchItemByField(requestParameters.term, requestParameters.entity_type, requestParameters.field, requestParameters.match, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches all leads by title, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found leads can be filtered by the person ID and the organization ID.
     * @summary Search leads
     * @param {BetaApiSearchLeadsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    searchLeads(requestParameters) {
        return BetaApiFp(this.configuration).searchLeads(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.person_id, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches all organizations by name, address, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope.
     * @summary Search organizations
     * @param {BetaApiSearchOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    searchOrganization(requestParameters) {
        return BetaApiFp(this.configuration).searchOrganization(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches all persons by name, email, phone, notes and/or custom fields. This endpoint is a wrapper of <a href=\"https://developers.pipedrive.com/docs/api/v1/ItemSearch#searchItem\">/v1/itemSearch</a> with a narrower OAuth scope. Found persons can be filtered by organization ID.
     * @summary Search persons
     * @param {BetaApiSearchPersonsRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    searchPersons(requestParameters) {
        return BetaApiFp(this.configuration).searchPersons(requestParameters.term, requestParameters.fields, requestParameters.exact_match, requestParameters.organization_id, requestParameters.include_fields, requestParameters.limit, requestParameters.cursor).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the properties of an activity.
     * @summary Update an activity
     * @param {BetaApiUpdateActivityRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    updateActivity(requestParameters) {
        return BetaApiFp(this.configuration).updateActivity(requestParameters.id, requestParameters.AddActivityRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Edits a discount added to a deal, changing the deal value if the deal has one-time products attached.
     * @summary Update a discount added to a deal
     * @param {BetaApiUpdateAdditionalDiscountRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    updateAdditionalDiscount(requestParameters) {
        return BetaApiFp(this.configuration).updateAdditionalDiscount(requestParameters.id, requestParameters.discount_id, requestParameters.UpdateAdditionalDiscountRequestBody).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the properties of a deal.
     * @summary Update a deal
     * @param {BetaApiUpdateDealRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    updateDeal(requestParameters) {
        return BetaApiFp(this.configuration).updateDeal(requestParameters.id, requestParameters.UpdateDealRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the details of the product that has been attached to a deal.
     * @summary Update the product attached to a deal
     * @param {BetaApiUpdateDealProductRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    updateDealProduct(requestParameters) {
        return BetaApiFp(this.configuration).updateDealProduct(requestParameters.id, requestParameters.product_attachment_id, requestParameters.UpdateDealProductRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the properties of a organization.
     * @summary Update a organization
     * @param {BetaApiUpdateOrganizationRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    updateOrganization(requestParameters) {
        return BetaApiFp(this.configuration).updateOrganization(requestParameters.id, requestParameters.UpdateOrganizationRequest).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the properties of a person.
     * @summary Update a person
     * @param {BetaApiUpdatePersonRequest} requestParameters Request parameters.

     * @throws {RequiredError}
     * @memberof BetaApi
     */
    updatePerson(requestParameters) {
        return BetaApiFp(this.configuration).updatePerson(requestParameters.id, requestParameters.UpdatePersonRequest).then((request) => request(this.axios, this.basePath));
    }
}
